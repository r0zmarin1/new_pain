## PHP ООП

Конечная цель объектно-ориентированного программирования (**PHP** **ООП**) — это создание программного кода, который можно переиспользовать и расширять в будущем. Однако для многих начинающих разработчиков, понимание **ООП** может быть сложным и запутанным.

Мы рассмотрим с вами основы ООП на PHP для новичков, включая концепции, такие как классы, объекты, наследование, полиморфизм и инкапсуляция. Мы также рассмотрим, как эти концепции применяются на практике при создании объектно-ориентированного кода на PHP.

## Что такое объектно-ориентированное программирование (ООП)?

Объектно-ориентированное программирование (**ООП**) — это подход к разработке программного обеспечения, который основывается на понятии объектов и их взаимодействия. В объектно-ориентированной парадигме программирования, программа разбивается на набор объектов, каждый из которых имеет свои **свойства** и **методы**.

ООП обеспечивает возможность создавать программное обеспечение, которое является более **модульным**, **гибким**, **масштабируемым** и **легко поддерживаемым**. Этот подход к программированию позволяет разделить функциональность программы на небольшие, логически связанные модули, что упрощает понимание кода, его тестирование и поддержку.

В объектно-ориентированной парадигме программирования основными понятиями являются **классы** и **объекты**. Класс — это шаблон, описывающий свойства и методы, которыми обладают объекты. Объект — это экземпляр класса, созданный во время выполнения программы. Объекты имеют свои свойства и методы, которые могут быть использованы для взаимодействия с другими объектами.

ООП также подразумевает использование **наследования** и **полиморфизма**. Наследование позволяет создавать новые классы на основе существующих, что позволяет сократить объем кода и упростить его поддержку. Полиморфизм позволяет объектам с одинаковым интерфейсом вести себя по-разному в зависимости от контекста их использования.

В PHP **объектно-ориентированное программирование** реализуется с помощью классов и объектов, которые могут быть созданы в любой части программы и могут использоваться в других частях программы. ООП в PHP предоставляет разработчикам большую гибкость и возможности для создания мощных и эффективных приложений.

## Классы и объекты. PHP ООП

ООП строится вокруг понятия классов и объектов. Класс — это шаблон, по которому создаются объекты. Он определяет набор свойств и методов, которые будут доступны объектам этого класса.

### Создание классов (PHP ООП)

Для создания класса в PHP используется ключевое слово «**class**», за которым следует имя класса и фигурные скобки, в которых определяются **свойства** и **методы** класса. Например:

```php
class Person {
  // Свойства класса
  public $name;
  public $age;

  // Методы класса
  public function sayHello() {
    echo "Hello, my name is ".$this->name." and I am ".$this->age." years old.";
  }
}
```

В этом примере определен класс **Person** с двумя свойствами — **name** и **age**, и методом **sayHello()**, который выводит приветствие с именем и возрастом человека.

### Создание объектов (PHP ООП)

Для создания объекта класса используется ключевое слово «**new**» и имя класса. Например:

```php
$person1 = new Person();
```

В этом примере создается объект **$person1** класса **Person**. Объекты класса содержат свойства и методы, определенные в классе. Свойства объектов можно установить и получить, используя оператор «**\->**». Например:

```php
$person1->name = "John";
$person1->age = 30;
$person1->sayHello();
```

### Конструкторы и деструкторы

**Конструктор** — это метод, который вызывается автоматически при создании объекта класса. [Конструкторы в PHP](https://geniuscourses.com/category/php/) имеют имя «**\_\_construct()**». Они могут использоваться для инициализации свойств объекта. Например:

```php
class Person {
  public $name;
  public $age;

  public function __construct($name, $age) {
    $this->name = $name;
    $this->age = $age;
  }

  public function sayHello() {
    echo "Hello, my name is ".$this->name." and I am ".$this->age." years old.";
  }
}

$person1 = new Person("John", 30);
$person1->sayHello();
```

В этом примере конструктор класса **Person** принимает два аргумента — **имя** и **возраст**. Они используются для **инициализации** свойств объекта.

**Деструктор** — это метод, который вызывается автоматически при уничтожении объекта класса. Деструкторы в PHP имеют имя «**\_\_destruct()**». Они могут использоваться для освобождения ресурсов, которые занимал объект. Например:

```php
class MyClass {
  public function __destruct() {
    // Освобождение ресурсов
  }
}
```

## Наследование

Наследование в ООП позволяет создавать новый класс на основе существующего класса, который называется родительским классом или суперклассом. Новый класс, созданный на основе существующего, называется дочерним классом или подклассом.

### Создание дочерних классов

При создании дочернего класса, он **наследует** все свойства и методы родительского класса, и может добавлять свои собственные свойства и методы. Таким образом, дочерний класс расширяет функциональность родительского класса.

Для создания дочернего класса в PHP используется ключевое слово `extends`. Например, если у нас есть класс `Animal`, мы можем создать дочерний класс `Cat`, который наследует свойства и методы от `Animal` следующим образом:

```php
class Animal {
  public $name;
  public function makeSound() {
    echo "The animal makes a sound.";
  }
}

class Cat extends Animal {
  public function makeSound() {
    echo "Meow!";
  }
}
```

В этом примере `Cat` является дочерним классом `Animal`. Он наследует свойство `$name` и метод `makeSound()` от `Animal`, а также добавляет свой собственный метод `meow()`.

### Множественное наследование

PHP **не** поддерживает множественное наследование классов. Но если нужно чтобы дочерний класс наследовал свойства и методы от нескольких родительских классов, тогда используйте `trait` . Например:

```php
trait Animal {
  public $name;
  public function makeSound() {
    echo "The animal makes a sound.";
  }
}

trait CanFly {
  public function fly() {
    echo "The animal can fly.";
  }
}

class Bat {
  use Animal, CanFly;

  public function makeSound() {
    echo "Screech!";
  }
}
```

В этом примере класс `Bat` использует трейты `Animal` и `CanFly` для доступа к их свойствам и методам.

**Трейты** — это более гибкий и безопасный способ реализации функциональности, похожей на множественное наследование, в PHP.

**Почему PHP не поддерживает множественное наследование классов?**

Существует несколько причин, почему PHP не поддерживает множественное наследование классов:

*   **Сложность**: Множественное наследование может привести к сложным и запутанным иерархиям классов, что может затруднить чтение и сопровождение кода.
*   **Проблемы с алмазными конфликтами**: Если два родительских класса имеют метод с одинаковым именем, то возникает алмазный конфликт, и неясно, какой метод должен быть вызван.
*   **Производительность**: Множественное наследование может привести к снижению производительности, так как код должен будет выполнять поиск в нескольких иерархиях классов.

**Использование трейтов** — это более простой, понятный и эффективный способ реализации функциональности, похожей на множественное наследование, в PHP.

## Полиморфизм

Полиморфизм — это способность объектов разных классов использовать одинаковые методы, что упрощает их взаимодействие. В PHP полиморфизм реализуется с помощью перегрузки методов, абстрактных классов и интерфейсов.

### Перегрузка методов

Перегрузка методов — это возможность определения нескольких методов с одним и тем же именем, но с разными параметрами. Таким образом, объекты могут вызывать метод с одним и тем же именем, но с разными параметрами, и получать разные результаты. Например, в классе «Калькулятор» можно определить метод «сумма», который будет принимать разное количество аргументов, в зависимости от того, сколько чисел нужно сложить.

### Абстрактные классы и интерфейсы

#### Что такое Интерфейсы

В общих чертах, Интерфейс должен описывать, как будет построен класс реализующий его, это похоже на план, описывающий публичные методы и константы, которые должны быть реализованы.

Интерфейсы **должны**:

*   Использоваться для определения публичных методов класса.
*   Использоваться для определения констант класса.

Интерфейсы **не должны**:

*   Использоваться сами по себе.
*   Использоваться для определения приватных или защищённых методов класса.
*   Использоваться для определения свойств класса.

Интерфейсы используются для определения публичных методов, которые должен включать класс. Важно помнить, что интерфейс всегда предназначен для реализации классом, поэтому в нём вы определяете только сигнатуру метода, например:

```php
interface HomeInterface{    const MATERIAL = 'Brick';    public function openDoor(): void;    public function getRooms(): array;    public function hasGarden(): bool;}
```

а не как в следующем примере:

```php
interface HomeInterface{    public string $material = 'Brick';    public function openDoor(): void    {        // Открываем дверь...    }    public function getRooms(): array    {        // Даём информацию о комнатах...    }    public function hasGarden(): bool    {        // Задаём есть ли у дома сад...    }}
```

Согласно [php.net](https://www.php.net/manual/en/language.oop5.interfaces.php), интерфейсы служат нескольким целям:

1.  Позволить разработчикам создавать объекты разных классов, которые могут использоваться взаимозаменяемо, поскольку они реализуют один и тот же интерфейс или интерфейсы. Типичный пример — несколько служб доступа к базе данных, несколько платёжных шлюзов или разные стратегии кэширования. Различные реализации могут быть заменены, не требуя каких-либо изменений в коде, который их использует.
2.  Позволить функции или методу принимать и оперировать параметром, который соответствует интерфейсу, не заботясь о том, что ещё может делать объект или как он реализован. Эти интерфейсы часто называют `Iterable`, `Cacheable`, `Renderable` и т.д., чтобы описать поведение.

Используя наш выше описанный интерфейс и придерживаясь аналогии с домом, мы могли бы создавать различные классы реализующие `HomeInterface` такие, как `House`, `Flat` или `Caravan`. Используя интерфейс, мы можем быть уверены, что наш класс содержит три необходимых метода и все используют правильную сигнатуру метода. Например, у нас может быть класс `House`, который выглядит так:

```php
class House implements HomeInterface{    public function openDoor(): void    {        // Открываем дверь здесь...    }    public function getRooms(): array    {        // Даём информацию о комнатах...    }    public function hasGarden(): bool    {        // Задаём есть ли у дома сад...    }}
```

#### Что такое Абстрактные классы

Абстрактные классы PHP очень похожи на интерфейсы PHP; они не предназначены быть классами сами по себе и представляют базовые методы без реализации.

Возьмём пример с домами, приведённый выше, если интерфейс является вашим планом, то абстрактный класс — это ваша модель выставочного зала. Он работает, и это отличный пример дома, но вам всё равно нужно его обставить и украсить, чтобы сделать его своим.

Абстрактный класс **может**:

*   Использоваться для определения сигнатур методов класса с использованием `abstract` методов (аналогично интерфейсам).
*   Использоваться для определения методов.
*   Использоваться для определения констант класса.
*   Использоваться для определения свойств класса.
*   Расширятся дочерним классом.

Абстрактный класс **не может**:

*   Использоваться самостоятельно

Что бы понять, что это означает, рассмотрим пример абстрактного класса:

```php
abstract class House{    const MATERIAL = 'Brick';    abstract public function openDoor(): void;    public function getRooms(): array    {        return [            'Bedroom',            'Bathroom',            'Living Room',            'Kitchen',        ];    }    public function hasGarden(): bool    {        return true;    }}
```

Наш класс `House` объявлен `abstract` — это означает, что мы не можем использовать его напрямую. Для использования нужно его унаследовать. Например, давайте создадим класс `MyHouse`, который расширяет абстрактный класс `House`:

```php
class MyHouse extends House{    public function openDoor(): void    {        // Открываем дверь...    }    public function getRooms(): array    {        return [            'Bedroom One',            'Bedroom Two',            'Bathroom',            'Living Room',            'Kitchen',        ];    }}
```

```php
// Это не будет работать:$house = new House();// Это будет работать:$house = new MyHouse();
```

Вы могли заметить, что в классе `House` мы объявили абстрактный публичный метод `openDoor()`. Это позволяет нам определить сигнатуру метода, которую дочерний класс должен включать, аналогично тому, как мы делали бы с интерфейсом. Это действительно удобно, если вы хотите поделиться функциональностью с дочерними классами, но при этом обеспечить возможность собственной реализации некоторых методов.

В этом случае дочерний класс мог бы переопределить методы `getRooms()` и `hasGarden()`, но не должен был бы их включать. Что продемонстрировать это, мы переопределили метод `getRooms()` показав, как мы можем изменить его поведение в дочернем классе.

#### Как решить, что использовать

Это зависит от вашей цели. Сохранив аналогию с домом, если вы создаёте чертежи, которые в дальнейшем можно использовать для проектирования домов разных типов, вам нужен интерфейс.

Если вы построили дом и вам нужно создать копии с улучшениями, то вам нужен абстрактный класс.

Приведу несколько примеров:

### Когда использовать Интерфейс

Чтобы помочь понять, когда нужно использовать интерфейс, давайте рассмотрим пример. Допустим, у нас ест класс `ConstructionCompany` включающий метод `buildHome()`, который выглядит следующим образом:

```php
class ConstructionCompany{    public function buildHome($home)    {        // Строим дом...        return $home;    }}
```

Теперь предположим, что у нас есть 3 разных класса, которые мо хотим создать и передать методу `buildHome()`:

1.  `class MyHouse implements HomeInterface extends House`
2.  `class MyCaravan implements HomeInterface`
3.  `class MyFlat implements HomeInterface`

Как мы видим, класс `MyHouse` расширяет абстрактный класс `House`; и это имеет смысл к концептуальной точки зрения, потому что дом есть дом. Однако класс `MyCaravan` или `MyFlat` не имеет смысла расширять от абстрактного класса, потому что ни один из них не является домом.

Итак, поскольку наша строительная компания может строить дома, фургоны и квартиры, это правило исключает указание параметра `$home` в методе `buildHome()` как экземпляра `House`.

Однако это было бы идеальным местом для указания типа нашему методу, что бы разрешить принимать только классы реализующие `HomeInterface`. В качестве примера мы могли бы обновить метод следующим образом:

```php
class ConstructionCompany{    public function buildHome(HomeInterface $home)    {        // Строим дом...        return $home;    }}
```

В результате мы можем быть уверенными, передавая значение дом, фургон или квартира, что наш класс ConstructionCompany получит необходимую информацию. Переданный объект `home` всегда будет содержать необходимые нам методы.

Вы могли подумать: Почему бы нам просто не создать абстрактный класс `Home` вместо интерфейса?. Однако важно помнить, что PHP поддерживает только одиночное наследование и что класс не может расширять более одного родителя. Таким образом, это будет довольно сложно, если вы захотите расширить один из своих классов в будущем.

#### Когда использовать Абстрактный класс

Возьмём сценарий аналогичный приведённому выше. Давайте представим, что у нас есть `HouseConstructionCompany`, похожая на нашу `ConstructionCompany`. Но в этом примере предположим, что компания `HouseConstructionCompany` строит только дома и ничего больше.

Поскольку мы знаем, что нам нужно уметь строить только дома, мы можем указать, что бы наш метод принимал только те классы, которые являются расширением абстрактного класса `Home`. Это может быть действительно полезно, так как мы всегда будем уверены, что передаём типы только тех домов которые строительная компания строит. Например:

```php
class HouseConstructionCompany{    public function buildHouse(House $house)    {        // Build the house here...        return $house;    }}
```


## Инкапсуляция

Инкапсуляция — это один из основных принципов ООП, который позволяет скрыть реализацию и детали работы объекта от других частей программы, обеспечивая доступ только к интерфейсу, который предоставляет объект. Таким образом, изменения внутренней реализации объекта не должны влиять на его взаимодействие с другими объектами.

### Защита свойств и методов класса

В PHP инкапсуляцию можно реализовать с помощью модификаторов доступа, таких как public, private и protected. Public-свойства и методы доступны из любой части программы. Private-свойства и методы доступны только изнутри класса. Protected-свойства и методы доступны только изнутри класса и его дочерних классов.

### Геттеры и сеттеры

Чтобы защитить свойства и методы класса, можно использовать модификаторы доступа. Для получения доступа к ним извне, можно использовать геттеры и сеттеры. Геттер — это метод, который возвращает значение определенного свойства объекта, а сеттер — это метод, который устанавливает значение этого свойства.

Абстрактные классы и интерфейсы являются другими способами реализации инкапсуляции в PHP. Абстрактный класс — это класс, который не может быть создан непосредственно, а может содержать абстрактные методы, которые должны быть реализованы в дочерних классах. Интерфейс — это набор методов без реализации, которые должны быть реализованы в классах, которые реализуют интерфейс. Использование абстрактных классов и интерфейсов позволяет более гибко организовать код и обеспечить более легкое масштабирование.

## Практический пример применения PHP ООП

Применение ООП на практике является одним из наиболее важных аспектов изучения ООП. После освоения основных концепций ООП, необходимо научиться применять их на практике для решения реальных задач.

Пример создания класса и объекта: Допустим, мы хотим создать класс `Человек`, который будет содержать свойства `имя`, `возраст`, `рост` и метод `sayHello()`. Вот как может выглядеть код для создания такого класса на PHP:

```php
class Person {
    public $name;
    public $age;
    public $height;

    public function sayHello() {
        echo "Привет, меня зовут " . $this->name;
    }
}
```

Затем мы можем создать объект этого класса и задать ему значения свойств:

```php
$person = new Person();
$person->name = "Иван";
$person->age = 30;
$person->height = 180;
```

Теперь мы можем вызвать метод `sayHello()` для объекта `$person` и он выведет сообщение `Привет, меня зовут Иван`.

### **Пример наследования и полиморфизма** PHP ООП

Предположим, мы хотим создать класс `Студент`, который наследует свойства и методы класса `Человек` и добавляет свои собственные свойства и методы. Вот как может выглядеть код для создания такого класса на PHP:

```php
class Student extends Person {
    public $university;

    public function study() {
        echo $this->name . " учится в " . $this->university;
    }
}
```

Теперь мы можем создать объект класса `Студент` и задать ему значения свойств, включая свойство `university`:

```php
$student = new Student();
$student->name = "Мария";
$student->age = 20;
$student->height = 170;
$student->university = "МГУ";
```

Мы можем вызвать метод `sayHello()` для объекта `$student` и он выведет сообщение `Привет, меня зовут Мария`. Также мы можем вызвать метод `study()` для объекта `$student` и он выведет сообщение `Мария учится в МГУ`.

### Пример инкапсуляции PHP ООП

Допустим, мы хотим создать класс `БанковскийСчет`, который будет содержать свойства `баланс` и `номерСчета`, и методы `снятьДеньги()` и `положитьДеньги()`. Однако мы не хотим, чтобы эти свойства и методы были доступны извне класса. Для этого мы можем использовать инкапсуляцию. Вот как может выглядеть код для создания такого Класса.

```php
class BankAccount {
    private $balance;
    private $accountNumber;
    
    public function __construct($balance, $accountNumber) {
        $this->balance = $balance;
        $this->accountNumber = $accountNumber;
    }
    
    public function withdraw($amount) {
        $this->balance -= $amount;
    }
    
    public function deposit($amount) {
        $this->balance += $amount;
    }
    
    public function getBalance() {
        return $this->balance;
    }
    
    private function generateTransactionNumber() {
        // логика генерации номера транзакции
    }
}
```

Здесь мы использовали модификаторы доступа `private` для свойств `$balance` и `$accountNumber`, а также для метода `generateTransactionNumber()`. Это означает, что эти свойства и метод не могут быть доступны извне класса, а доступ к ним осуществляется только через публичные методы `withdraw()`, `deposit()` и `getBalance()`. Это обеспечивает защиту свойств и методов класса от неправильного использования и повышает безопасность приложения.


[<- Вернутся к содержанию](/doc/index.md)



